---
layout: post
title:  KSCrash 奔溃原理分析
category: KSCrash
comments: true
---

本文主要通过分析[KSCrash](https://github.com/kstenerud/KSCrash)框架，了解IOS程序奔溃后，如何获取奔溃时的符号化的调用堆栈，方便开发人员及时的解决程序中的bug。

程序奔溃后，获取调用堆栈的过程，是程序正常执行的逆向分析过程，所以本文首先通过了解程序执行的正向过程。了解了程序编译执行的正向过程，对于逆向分析非常有帮助。


# 一、程序执行的正向编译执行

本节描述的过程只是按照自己的理解编写的，具体安排的逻辑和内容的不一定合理。安排的具体思路基本依照编译执行的过程正向过程。其中穿插着一些KSCrash解析的时候使用的知识。

下面首先了解  将程序员编写的代码转化为可执行文件的过程。


## 1. 编译


开发者通过IDE，将源码文件转化为临时中间文件，然后使用链接器（/usr/bin/ld）将临时的对象文件（object file）合并为可执行文件，在ios系统中，这种文件的格式是Mach-O类型。

上面提到了Mach-o文件格式，那么这到底是一种什么样的格式呢？

## 2. Mach-O文件结构

Mach-O (Mach object) file format 是mac系统上存储程序和库（libraries）的标准格式。它是BSD系统中.a文件格式的替代物，它封装着程序的可执行代码和数据。

具体的参考文档如下：
[ OS X ABI Mach-O File Format Reference](https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html#//apple_ref/doc/uid/20001298-96661)

一个Mach-O文件包括三个组成部分，分别如下：

* header：指定了文件的构架，如PPC、PPC64、IA-32、x86-64。
* Load commands：指定了文件的逻辑结构、在虚拟内存（virtual memory）中文件的布局
* Raw segment data：包含在load commands中定义的段（segments）数据

![Mach-O文件结构]({{site.url}}/images/KSCrash/1.png)

#### header 文件头

Mach-O文件的开头是文件头
文件头结构在/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/include/mach-o/loader.h文件中定义如下：

~~~
struct mach_header {
	uint32_t	magic;		/* mach magic number identifier */
	cpu_type_t	cputype;	/* cpu specifier */
	cpu_subtype_t	cpusubtype;	/* machine specifier */
	uint32_t	filetype;	/* type of file */
	uint32_t	ncmds;		/* number of load commands */
	uint32_t	sizeofcmds;	/* the size of all the load commands */
	uint32_t	flags;		/* flags */
};
~~~

可以看出包括了 ：魔数、cup的类型、子类型、文件的类型、load commend个数、大小等数据。

header 后面紧跟着的内容是load commend。load commend指定了文件的布局。具体包括以下内容：

• The initial layout of the file in virtual memory
• The location of the symbol table (used for dynamic linking)
• The initial execution state of the main thread of the program
• The names of shared libraries that contain definitions for the main executable’s imported symbols

~~~
#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */
#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */
#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */
#define	LC_THREAD	0x4	/* thread */
#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */
#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */
#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */
#define	LC_IDENT	0x8	/* object identification info (obsolete) */
#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */
#define LC_PREPAGE      0xa     /* prepage command (internal use) */
#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */
#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */
#define	LC_ID_DYLIB	0xd	/* dynamically linked shared lib ident */
#define LC_LOAD_DYLINKER 0xe	/* load a dynamic linker */
#define LC_ID_DYLINKER	0xf	/* dynamic linker identification */
#define	LC_PREBOUND_DYLIB 0x10	/* modules prebound for a dynamically */
~~~

在load commend后面是load commend中定义的各种segement数据。每个segement 包含0或多个section，每个segement中的section包含特定类型的代码和数据 。


下面有几个工具可以简单的查看文件的结构：

*  文件类型展示工具-file ，The file-type displaying tool, 位于/usr/bin/file，显示文件的类型，对于多构架的文件，它显示每个构架下的镜像类型。

~~~
file /Users/gome/Desktop/GomeEShop 

/Users/gome/Desktop/GomeEShop: Mach-O 64-bit executable
~~~

* 对象文件展示工具-otool ，The object-file displaying tool，位于/usr/bin/otool，显示Mach-O 格式文件的sections、segments的内容。它包含各个构架下的符号

~~~
bogon:~ LiJian$ otool -h /Users/gome/Desktop/GomeEShop 
/Users/gome/Desktop/GomeEShop:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
 0xfeedfacf 16777228          0  0x00           2    59       6648 0x00218085

~~~

可以使用otool工具 查看符号化的文件头

~~~
bogon:~ LiJian$ otool -hv /Users/gome/Desktop/GomeEShop 
/Users/gome/Desktop/GomeEShop:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    59       6648   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE
bogon:~ LiJian$ 
~~~

可以使用otool 查看load commend。

~~~
bogon:~ LiJian$ otool -lv /Users/gome/Desktop/GomeEShop 
/Users/gome/Desktop/GomeEShop:
Load command 0
      cmd LC_SEGMENT_64
  cmdsize 72
  segname __PAGEZERO
   vmaddr 0x0000000000000000
   vmsize 0x0000000100000000
  fileoff 0
 filesize 0
  maxprot ---
 initprot ---
   nsects 0
    flags (none)
Load command 1
      cmd LC_SEGMENT_64
  cmdsize 952
  segname __TEXT
   vmaddr 0x0000000100000000
   vmsize 0x000000000229c000
  fileoff 0
 filesize 36290560
  maxprot r-x
 initprot r-x
   nsects 11
    flags (none)
Section
.......
~~~

* 符号展示工具-nm，The symbol table display tool,位于 /usr/bin/nm, allows you to view the contents of an object file’s symbol table.

~~~
bogon:~ LiJian$ nm /Users/gome/Desktop/GomeEShop 
0000000100c087a4 t +[ADBAnalyticsTimedAction timedAction:data:startTime:adjustedStartTime:databaseID:]
0000000100c08730 t +[ADBAnalyticsTimedAction timedAction:startData:]
0000000100c093f0 t +[ADBAnalyticsTrackTimedAction allocWithZone:]
0000000100c09400 t +[ADBAnalyticsTrackTimedAction copyWithZone:]
000000010143b458 t -[GMFLoginVC initNavView]
000000010143b0ec t -[GMFLoginVC initVariable]
000000010143b2c8 t -[GMFLoginVC initViews]
000000010143b524 t -[GMFLoginVC isBtnLoginEnable]
000000010144a904 t -[GMFLoginVC isInstallWeChart]
000000010144a96c t -[GMFLoginVC isWechartLogin]
000000010144a4d0 t -[GMFLoginVC loginFailedBlock]
000000010143f04c t -[GMFLoginVC loginFailed]
000000010144a45c t -[GMFLoginVC loginSuccessBlock]
000000010143ecdc t -[GMFLoginVC loginSuccessed:]
000000010144a9d4 t -[GMFLoginVC needCaptchaUserName]
000000010144abb0 t -[GMFLoginVC reqAliPayAuthASeccess]
000000010144ab38 t -[GMFLoginVC reqAuthParamOfAliPay]
0000000101446320 t -[GMFLoginVC reqFail_URL_AliPayParam:]
......
~~~


## 3. 绑定和执行

根据上面分析的可执行文件的结构，我们可以看到，可执行文件中已经包含了符号表 ，这个符号表是可执行代码的虚拟地址和符号的对应表。符号表是绑定过程中建立的，程序的绑定有很多种，我自己也不清楚，不过可以参看下面的文档：[Mach-O Programming Topics - Binding Symbols](https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829-97047-TPXREF111)

看到符号表，那么我们可以做这样的设想： 如果程序奔溃，只要我们获取到了奔溃调用堆栈的回溯地址，然后从这个符号表中查找对应的符号，就完成了调用堆栈的符号化工作？ 还有一个问题就是我们如何获取程序的调用堆栈呢？还有很多需要我们接着往下看。为了知道如何获取调用堆栈的回溯，我们大概了解下程序的执行过程：

程序的执行过程：内核首先加载程序文件，并且检查程序文件的起始部分的mach_header结构，内核验证是否合法的Macj-O文件，解析header中的load commands。然后内核加载在load commands 中指定的动态链接器到内存中，执行。


## 4. 调用堆栈

一个线程的调用栈是什么样的呢？

我的理解是应该包含当前线程的执行地址，并且从这个地址可以一级一级回溯到线程的入口地址，这样就反向构成了一条链：线程入口执行某个方法，然后逐级嵌套调用到当前现场。

![Mach-O文件结构]({{site.url}}/images/KSCrash/2.png)

如图所示，每一级的方法调用，都对应了一张活动记录，也称为活动帧。也就是说，调用栈是由一张张帧结构组成的，可以称之为栈帧。

我们可以看到，一张栈帧结构中包含着Return Address，也就是当前活动记录执行结束后要返回的地址。

那么我们只要获取到了当前指令地址rip，就可以获取到栈基址指针rbp、当前栈帧地址rsp。进一步回溯到各个调用的活动栈。

那么问题来了，我们怎么获取到指令的地址呢？ 其实当前指令执行地址rip、栈基址指针rbp、当前栈帧地址rsp 都是在cup的寄存器中保存着。下面大概介绍下寄存器。  


## 5. 寄存器 

想了解IOS 的arm64的框架的相关寄存器可以参考下面的资料：[Procedure Call Standard for the ARM 64-bit Architecture (AArch64)](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf)。

下面是我从代码中整理出的arm64的寄存器的定义，从下面代码中也可以大概了解寄存器的基本情况。

其中结构体STRUCT_MCONTEXT_L 定义了三大类寄存器，分别是：异常寄存器、线程状态寄存器、浮点寄存器。下面代码位于/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/include/mach/i386/_structs.h文件中，其中我后面添加注释的是比较重要的寄存器。

~~~
_STRUCT_MCONTEXT64
{
 
	_STRUCT_X86_EXCEPTION_STATE64  __es; ///异常寄存器
	_STRUCT_X86_THREAD_STATE64  __ss;  ///线程状态寄存器
	_STRUCT_X86_FLOAT_STATE64  __fs;  ///浮点寄存器
};
~~~

///异常寄存器

~~~
_STRUCT_X86_EXCEPTION_STATE64
{
    __uint16_t	__trapno;
    __uint16_t	__cpu;
    __uint32_t	__err;
    __uint64_t	__faultvaddr;   /// 这个就是奔溃的地址
};
~~~

///线程状态寄存器

~~~
_STRUCT_X86_THREAD_STATE64
{
	__uint64_t	__rax;
	__uint64_t	__rbx;
	__uint64_t	__rcx;
	__uint64_t	__rdx;
	__uint64_t	__rdi;
	__uint64_t	__rsi;
	__uint64_t	__rbp; /// 栈帧指针（栈基指针）
	__uint64_t	__rsp; /// 当前栈地址
	__uint64_t	__r8;
	__uint64_t	__r9;
	__uint64_t	__r10;
	__uint64_t	__r11;
	__uint64_t	__r12;
	__uint64_t	__r13;
	__uint64_t	__r14;
	__uint64_t	__r15;
	__uint64_t	__rip;  /// 当前指令寄存器
	__uint64_t	__rflags;
	__uint64_t	__cs;
	__uint64_t	__fs;
	__uint64_t	__gs;
};
~~~

了解了arm64的寄存器，那么下面的问题来了，程序奔溃后，如何获取这些寄存器的内容呢？ 我们需要了解下xnu微内核，xnu微内核的进程内通信部分（IPC），暴露了一些接口，可以获取当前线程的寄存器，可以参考下面的文档，了解这些函数的接口定义：[Mach IPC Interface](http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/)。[IPC 原理讲解](https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html)。

## 6. 线程执行状态

IPC 接口文档的线程接口部分（Thread Interface）的 thread_get_state函数可以获取线程的寄存器。他的定义如下

~~~
kern_return_t   thread_get_state
                (thread_act_t                     target_thread,
                 thread_state_flavor_t                   flavor,
                 thread_state_t                       old_state,
                 mach_msg_type_number_t         old_state_count);
~~~

thread_get_state 函数返回target_thread的执行状态（包括机器的寄存器）。

## 7. 思路回溯

符号化奔溃时的调用堆栈，可以按照下面的思路进行：

1. 通过thread_get_state 获取当前线程的寄存器状态，主要是获取：栈基址指针rbp、当前栈帧地址rsp

2. 根据第四部分讲解的函数调用堆栈原理，取出各个 调用栈。

3. 根据第二部分讲解的Mach-O文件结构 中的符号表将各个调用栈符号化。


那么现在基本梳理清楚了思路，下面其实还有个问题，那就是我们如何知道程序奔溃呢？通过分析KS的代码，我们知道，我们可以在启动的时候注册奔溃的处理函数，程序奔溃时，会执行回调的处理函数。这样我们就知道了程序的奔溃。到现在为止，基本上梳理完了奔溃符号解析的过程。下面在了解下 到底什么导致程序的奔溃呢？。

## 8 Mach 异常与 Unix 信号

下面这部分内容是完全参考[漫谈 iOS Crash 收集框架](http://www.wtoutiao.com/p/h27ist.html)的。这个文章写的特别好，可以多看几次。

iOS 系统自带的 Apple’s Crash Reporter 记录在设备中的 Crash 日志，Exception Type 项通常会包含两个元素： Mach 异常 和 Unix 信号。

~~~
Exception Type:         EXC_BAD_ACCESS (SIGSEGV)    
Exception Subtype:      KERN_INVALID_ADDRESS at 0x041a6f3
~~~

Mach 异常是什么？它又是如何与 Unix 信号建立联系的？
Mach 是一个 XNU 的微内核核心，Mach 异常是指最底层的内核级异常，被定义在 <mach/exception_types.h>下 。每个 thread，task，host 都有一个异常端口数组，Mach 的部分 API 暴露给了用户态，用户态的开发者可以直接通过 Mach API 设置 thread，task，host 的异常端口，来捕获 Mach 异常，抓取 Crash 事件。

所有 Mach 异常都在 host 层被ux_exception转换为相应的 Unix 信号，并通过threadsignal将信号投递到出错的线程。iOS 中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。

因此，EXC_BAD_ACCESS (SIGSEGV)表示的意思是：Mach 层的EXC_BAD_ACCESS异常，在 host 层被转换成 SIGSEGV 信号投递到出错的线程。既然最终以信号的方式投递到出错的线程，那么就可以通过注册 signalHandler 来捕获信号:

~~~
signal(SIGSEGV,signalHandler);
~~~

捕获 Mach 异常或者 Unix 信号都可以抓到 crash 事件，这两种方式哪个更好呢？优选 Mach 异常，因为 Mach 异常处理会先于 Unix 信号处理发生，如果 Mach 异常的 handler 让程序 exit 了，那么 Unix 信号就永远不会到达这个进程了。转换 Unix 信号是为了兼容更为流行的 POSIX 标准 (SUS 规范)，这样不必了解 Mach 内核也可以通过 Unix 信号的方式来兼容开发。


# 二、KS 奔溃流程分析

下面是KS的基本流程

![Mach-O文件结构]({{site.url}}/images/KSCrash/3.png)

根据[KSCrash](https://github.com/kstenerud/KSCrash)的介绍，他可以捕获多种异常,包括：

* Mach kernel exceptions  
* Fatal signals  
* C++ exceptions  
* Objective-C exceptions  
* Main thread deadlock (experimental)  
* Custom crashes (e.g. from scripting languages)  

下面主要介绍下 Mach kernel exceptions、Fatal signals、C++ exceptions异常的注册异常处理函数原理。

## 1. Mach kernel exceptions 注册异常处理函数

下面是mach exceptions 的安装流程图

![Mach-O文件结构]({{site.url}}/images/KSCrash/mach 异常安装.png)   

基本流程是：

1. 首先调用task_get_exception_ports 保存先前的异常处理端口
2. 调用mach_port_allocate  创建异常处理端口g_exceptionPort，xnu的进程内通信可以通过端口进行。
3. 调用 mach_port_insert_right 获取端口的权限
4. 设置异常处理端口  
5. 创建线程，线程中不停的调用mach_msg ，读取g_exceptionPort端口上的数据，如果异常发生，mach_msg成功，进入异常处理流程。
6. 恢复先前的异常处理端口
7. 调用ksmachexc_i_fetchMachineState 获取线程状态。
8. 保存状态并完成符号化功能。
9. 卸载异常处理函数。


## 2. signals exceptions 注册异常处理函数




Interprocess Communication (IPC)

Communication between tasks is an important element of the Mach philosophy. Mach supports a client/server system structure in which tasks (clients) access services by making requests of other tasks (servers) via messages sent over a communication channel.

在任务间交互式mach的重要元素。Mach 支持client/server结构，在这种结构中，客户端任务向服务端任务发送请求，访问服务端的服务。

The endpoints of these communication channels in Mach are called ports, while port rights denote permission to use the channel. The forms of IPC provided by Mach include

在mach中发送消息的交互通道叫做prot，端口的权限标识了使用channel的许可，IPC的种类包括：
message queues
semaphores
notifications
lock sets
remote procedure calls (RPCs)

mach_task_self
mach_port_t   mach_task_self (void)
The mach_task_self function returns send rights to the task's kernel port.返回（具有向任务内核发送权利的）端口


kern_return_t   task_get_exception_ports
                (task_t                                    task,
                 exception_mask_t               exception_types,
                 exception_mask_array_t     old_exception_masks,
                 old_exception_masks        old_exception_count,
                 exception_port_array_t     old_exception_ports,
                 exception_behavior_array_t       old_behaviors,
                 exception_flavor_array_t           old_flavors);
                 
                 

替换信号处理函数栈 

int sigaltstack(const stack_t *ss, stack_t *oss);</signal.h>
g_signalStack


SIGABRT,     /* abort() */
    SIGBUS,  /* bus error */
    SIGFPE,  /* floating point exception */
    SIGILL,  /* illegal instruction (not reset when caught) */
    SIGPIPE,  /* write on a pipe with no one to read it */
    SIGSEGV,  /* segmentation violation */
    SIGSYS,  /* bad argument to system call */
    SIGTRAP,  /* trace trap (not reset when caught) */
    
    sigaction
   

int sigaction(int signo,const struct sigaction *restrict act,
              struct sigaction *restrict oact);
给信号signum设置新的信号处理函数act， 同时保留该信号原有的信号处理函数oldact


信号

“可替换信号栈” 的位置及属性信息
{
	void            *ss_sp;	        /* signal stack base */
	__darwin_size_t ss_size;        /* signal stack length */
	int             ss_flags;       /* SA_DISABLE and/or SA_ONSTACK */
};