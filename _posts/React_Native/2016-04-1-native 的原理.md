---
layout: post
title:  native原理
category: 技术
comments: true
---


# 简介

reactnative 引入的原理可以参考 [把现代web科技带给移动开发者](http://bbs.reactnative.cn/topic/14/react-native-把现代web科技带给移动开发者),下面是自己的一点总结：

## 1.1 开发原生的APP 比较困难

开发成本高，耗时，每次发版受apple的限制。

## 1.2 开发原生开发非常必要 

1. 原生APP 的用户体验比web Hybird APP 的用户体验好 
2. 在web上，我们也没有一个足够完善的线程模型，很难利用多线程并行执行工作

## 1.3 将两个世界合二为一？

 用脚本封装原生，即用JavaScript去调用原生API，优点：

1. 能获得原生平台的所有强大之处
2. 同时还能享受快速迭代和使用我们现有JavaScript上基础设施的好处
3. 因为基于JavaScript构建，我们应当能使得这样技术栈跨平台。

## 1.4 用脚本封装原生是一件需要技巧的事情

如果我们只是同步的在原生环境和解释环境之间调用，我们的UI线程很可能会被JavaScript执行阻塞住。要提升界面的响应效率，我们知道我们必须把JavaScript放到主线程之外执行，但这么做其实很困难。最直接的困难就是资源访问竞争。如果我们的JavaScript访问什么正好在被别的线程用的东西（譬如一个渲染的View的尺寸），系统就只能加锁来确保方案安全，而这又会导致UI线程的卡顿。还有一个问题在于每次原生和JavaScript虚拟机之间互相访问，在访问过程中都会带来极大的开销。如果我们要经常跨线程访问，我们不得不一次又一次的经历这种开销。

## 1.5 引入React Native


native 的目标是“一处学习，处处编写”，为了实现这个目标，mvc 模块的view 使用jsx（jsx 是js 和xml 混合编写代码的方式，是个语法糖，简化了js处理DOM的过程 ）编写。 ios 端和android端都在自己的平台上实现自己的原生模块的功能，然后暴露出统一的接口， jsx就可以不分平台的控制界面 。

为了能让js调用原生的方法或者认识原生的方法，原生模块需要遵守一定的协议。

# 原生模块的规范约定

RCTBridgeModule 桥协议

~~~
#define RCT_EXPORT_MODULE(js_name) \
RCT_EXTERN void RCTRegisterModule(Class); \
+ (NSString *)moduleName { return @#js_name; } \
+ (void)load { RCTRegisterModule(self); }
~~~

可选的协议

~~~
#define RCT_EXPORT_METHOD(method) \
  RCT_REMAP_METHOD(, method)
~~~

　　　　   UIView *subVIew = [[UIView alloc] initWithFrame:CGRectMake(100, 300, 50, 50)];
subVIew.backgroundColor = [UIColor grayColor];
[self.view addSubview:subVIew];
CAShapeLayer *shaper = [CAShapeLayer layer];
//    UIBezierPath *base = [UIBezierPath bezierPathWithArcCenter:CGPointMake(25, 25)
//                                                                  radius:10
//                                                              startAngle:0
//                                                                endAngle:2 * M_PI
//                                                               clockwise:YES];
//    shaper.path = base.CGPath;

shaper.strokeColor   = [UIColor greenColor].CGColor;   // 边缘线的颜色
shaper.lineWidth = 2.0;
shaper.fillRule = kCAFillRuleEvenOdd;
shaper.fillColor     = [UIColor redColor].CGColor;   // 闭环填充的颜色
shaper.lineCap       = kCALineCapSquare;               // 边缘线的类型
[subVIew.layer addSublayer:shaper];

CGMutablePathRef muPath = CGPathCreateMutable();

CGPathAddRect(muPath, nil, CGRectMake(5, 5, 40, 40));

CGPathAddRoundedRect(muPath, nil, CGRectMake((50-10)/2,(50-10)/2, 10, 10), 5, 5);


UIBezierPath *pazPath = [UIBezierPath bezierPathWithCGPath:muPath];
//    [pazPath closePath];
shaper.path = pazPath.CGPath;



CGMutablePathRef muPathEnd = CGPathCreateMutable();

CGPathAddRect(muPathEnd, nil, CGRectMake(5, 5, 40, 40));

CGPathAddRoundedRect(muPathEnd, nil, CGRectMake((50-40)/2,(50-40)/2, 40, 40), 20, 20);


UIBezierPath *pazPathEnd = [UIBezierPath bezierPathWithCGPath:muPathEnd];


CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"path"];
animation.removedOnCompletion = NO;
animation.repeatCount = 100;
animation.autoreverses = YES;
animation.fillMode = kCAFillModeForwards;
animation.duration = 2.0;
animation.fromValue = (__bridge id _Nullable)(muPath);
animation.toValue = (__bridge id _Nullable)(muPathEnd);

[shaper addAnimation:animation forKey:@"aa"];
